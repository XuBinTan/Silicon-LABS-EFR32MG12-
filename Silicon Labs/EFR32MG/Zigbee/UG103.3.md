# UG103.3: Application Development Fundamentals: Design Choices
--应用程序开发基础：设计选择

``` 
本文档根据如何构建无线网络解决方案必须做出的重大决策来描述应用程序设计过程。
```  

硅实验室的应用程序开发基础系列涵盖了项目经理、应用程序设计人员和开发人员在开始 使用硅实验室芯片、诸如EmberZNetpro或硅实验室蓝牙智能的网络栈和相关开发工具开发 嵌入式网络解决方案之前应该了解的主题。对于任何需要介绍开发无线网络应用程序的人 ，或者是对硅实验室开发环境来说 ，这些文档都是一个起点。  


**要点:**  

- 要使用哪个堆栈或应用程序框架？  
- SoC or NCP?  
- Zigbee design choices  


**目录**


  * [<strong>1\. 背景(Background)</strong>](#1-%E8%83%8C%E6%99%AFbackground)
  * [<strong>2\. 一般设计选择(General Design Choices)</strong>](#2-%E4%B8%80%E8%88%AC%E8%AE%BE%E8%AE%A1%E9%80%89%E6%8B%A9general-design-choices)
    * [<strong>2\.1 您应该使用哪种无线协议？</strong>](#21-%E6%82%A8%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E6%97%A0%E7%BA%BF%E5%8D%8F%E8%AE%AE)
    * [<strong>2\.2 SoC or NCP?</strong>](#22-soc-or-ncp)
    * [<strong>2\.3 SoC方式</strong>](#23-%E7%B3%BB%E7%BB%9F%E7%89%87%E4%B8%8A%E6%96%B9%E6%B3%95)
    * [<strong>2\.3 NCP方式</strong>](#23-%E9%87%87%E7%94%A8%E4%B8%B2%E8%A1%8C%E5%8D%8F%E8%AE%AE%E7%9A%84ncp%E6%96%B9%E6%B3%95)
    * [<strong>2\.3 设计差异</strong>](#23-%E8%AE%BE%E8%AE%A1%E5%B7%AE%E5%BC%82)
  * [<strong>3\. ZigBee设计选择(Zigbee Design Choices)</strong>](#3-zigbee%E8%AE%BE%E8%AE%A1%E9%80%89%E6%8B%A9zigbee-design-choices)
    * [<strong>3\.1 单一网络与多网络</strong>](#31-%E5%8D%95%E4%B8%80%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%A4%9A%E7%BD%91%E7%BB%9C)
      * [<strong>3\.1\.1 协调器/路由器网络休眠终端设备网络</strong>](#311-%E5%8D%8F%E8%B0%83%E5%99%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BD%91%E7%BB%9C%E4%BC%91%E7%9C%A0%E7%BB%88%E7%AB%AF%E8%AE%BE%E5%A4%87%E7%BD%91%E7%BB%9C)
      * [<strong>3\.1\.1 协调器/路由器网络休眠终端设备网络</strong>](#311-%E5%8D%8F%E8%B0%83%E5%99%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BD%91%E7%BB%9C%E4%BC%91%E7%9C%A0%E7%BB%88%E7%AB%AF%E8%AE%BE%E5%A4%87%E7%BD%91%E7%BB%9C-1)
    * [<strong>3\.2 网络发现和调试</strong>](#32-%E7%BD%91%E7%BB%9C%E5%8F%91%E7%8E%B0%E5%92%8C%E8%B0%83%E8%AF%95)
      * [<strong>3\.2\.1 通过扩展的PAN id或信道掩码简化网络选择</strong>](#321-%E9%80%9A%E8%BF%87%E6%89%A9%E5%B1%95%E7%9A%84pan-id%E6%88%96%E4%BF%A1%E9%81%93%E6%8E%A9%E7%A0%81%E7%AE%80%E5%8C%96%E7%BD%91%E7%BB%9C%E9%80%89%E6%8B%A9)
      * [<strong>3\.2\.2 许可证连接控制</strong>](#322-%E8%AE%B8%E5%8F%AF%E8%AF%81%E8%BF%9E%E6%8E%A5%E6%8E%A7%E5%88%B6)
      * [<strong>3\.2\.3 避免调试过程中的意外后果</strong>](#323-%E9%81%BF%E5%85%8D%E8%B0%83%E8%AF%95%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%84%8F%E5%A4%96%E5%90%8E%E6%9E%9C)
      * [<strong>3\.2\.4 断开机制</strong>](#324-%E6%96%AD%E5%BC%80%E6%9C%BA%E5%88%B6)
    * [<strong>3\.3 设备发现和配置</strong>](#33-%E8%AE%BE%E5%A4%87%E5%8F%91%E7%8E%B0%E5%92%8C%E9%85%8D%E7%BD%AE)
      * [<strong>3\.3\.1 何时发现和提供</strong>](#331-%E4%BD%95%E6%97%B6%E5%8F%91%E7%8E%B0%E5%92%8C%E6%8F%90%E4%BE%9B)
      * [<strong>3\.3\.2 识别分组法</strong>](#332-%E8%AF%86%E5%88%AB%E5%88%86%E7%BB%84%E6%B3%95)
      * [<strong>3\.3\.3 按钮法</strong>](#333-%E6%8C%89%E9%92%AE%E6%B3%95)
      * [<strong>3\.3\.4 匹配描述符请求方法</strong>](#334-%E5%8C%B9%E9%85%8D%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95)
      * [<strong>3\.3\.5 简单描述符请求方法</strong>](#335-%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95)
      * [<strong>3\.3\.6 供应工具法</strong>](#336-%E4%BE%9B%E5%BA%94%E5%B7%A5%E5%85%B7%E6%B3%95)
      * [<strong>3\.3\.7 地址发现</strong>](#337-%E5%9C%B0%E5%9D%80%E5%8F%91%E7%8E%B0)
    * [<strong>3\.4 线路建立</strong>](#34-%E7%BA%BF%E8%B7%AF%E5%BB%BA%E7%AB%8B)
      * [<strong>3\.4\.1 背景\-多对一个路由</strong>](#341-%E8%83%8C%E6%99%AF-%E5%A4%9A%E5%AF%B9%E4%B8%80%E4%B8%AA%E8%B7%AF%E7%94%B1)
      * [<strong>3\.4\.2 它是如何在ZigBee pro中工作的？</strong>](#342-%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%9C%A8zigbee-pro%E4%B8%AD%E5%B7%A5%E4%BD%9C%E7%9A%84)
    * [<strong>3\.5 消息传递</strong>](#35-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92)
      * [<strong>3\.5\.1 发送消息</strong>](#351-%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF)
      * [<strong>3\.5\.2 接收消息</strong>](#352-%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF)
      * [<strong>3\.5\.2 确认消息</strong>](#352-%E7%A1%AE%E8%AE%A4%E6%B6%88%E6%81%AF)
    * [<strong>3\.6 NCP与主机应用程序兼容性</strong>](#36-ncp%E4%B8%8E%E4%B8%BB%E6%9C%BA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%85%BC%E5%AE%B9%E6%80%A7)
    * [<strong>3\.7 安全</strong>](#37-%E5%AE%89%E5%85%A8)








## **1. 背景(Background)** 
 
当我们进入一个家中的设备都相互连接的世界时，Silicon　Labs正在正在开发满足客户需
求的产品。这通常被称之为物联网。在高层次上，物联网对硅实验室的目标是： 

* 将家中的所有设备与一流的网络连接起来，无论是使用zigbeeepro、线程、蓝牙智能还
是其他新兴标准。 
* 利用公司在能源友好型微控制器方面的专长。 
* 增强已建立的低功耗混合信号芯片。
* 启用云服务和与智能手机和平板电脑的连接，从而提高用户的易用性和共同的用户体验。 

实现所有这些目标将提高接入家庭的物联网设备的使用率和用户接受率。随着应用程序
设计器可用选项范围的增加，早期设计选择的影响也会增加。本文档描述了应用程序设
计过程中必须做出的关于如何构建无线网络工作解决方案的重大决策。

基本设计选择包括：

* 使用哪种硅实验室无线技术 
* 是采用soc(片上系统)设计还是ncp(网络协处理器)设计。
* 如果使用ncp模型，如何选择兼容的ncp和主机应用程序。

开发ZigBee解决方案时的设计选择包括： 

* 如何创建网络(form, join, or leave)
* 将使用什么样的安全模型
* 在网络中使用什么样的路由优化
* 如何通过网络传递消息  

一旦考虑了这些选择，就可以开始实现系统设计了。  

## **2. 一般设计选择(General Design Choices)**  

在开始使用硅实验室的无线微控制器进行无线设计之前，您应该首先考虑哪些可用的网络
技术最适合您的项目。一旦您决定了要用于您的设计的网络协议，请考虑您的产品是最适
合于片上系统（Soc）范式还是网络协处理器（Ncp）模式，对于ncp来说，要使用何种串行

通信来控制协处理器。

### **2.1 您应该使用哪种无线协议？**

Silicon Labs 在the Wireless Gecko family的开发提供了以下的堆栈： 

* Silicon　Labs　Flex　SDK包括：基于IEEE802.15.4的“连接”堆栈用于多跳“星型”网络
拓扑，以及用于具有自定义RF配置的真正专有设计的无线电抽象接口库(Rails)。
* EmberZNet，一个基于ZigBee　Pro的网格网络栈，在ug103.2中详细描述了：应用
程序开发基础：ZigBee。
* 硅实验室线程，一个基于1.1线程的IPv6　Mesh网络栈，在ug103.11中详细描述了：
应用程序开发基本原理：Thread。
* 硅实验室蓝牙SDK，一种基于蓝牙2.3的网络栈，在ug103.14中详细描述了：应用程
序开发基础：蓝牙智能技术。

在熟悉了这些协议的细节之后，您可能会根据您对标准遵从性、网络拓扑、互操作性、
频率范围和消息吞吐量的需求来选择这些协议。

### **2.2 SoC or NCP?**  

无论您是否使用应用程序框架进行设计，设计范式─的选择，无论是soc(sys-tem-on-Chip)
模型还是ncp（串行网络协处理器）模型─都是至关重要的。它决定了软件和硬件的要求和
约束。此选择控制应用程序相对于核心堆栈功能驻留的位置。在SoC模型中，整个系统（堆
栈和应用程序）驻留在单个芯片上，而在NCP模型中，堆栈处理是在一个单独的“协处理器”
中完成的，它通过外部串行接口与应用程序自己的微控制器交互。 

下图说明了堆栈和应用程序的各种组件，以及它们是如何相对于SoC或NCP体系结构模型进行组织的。

![](https://github.com/XuBinTan/Silicon-LABS-EFR32MG12-/blob/master/Silicon%20Labs/EFR32MG/photo/Slicon%20UG103.3%20F2.1.jpg)

虽然在体系结构之间进行选择是不容易的，但应用程序框架在某种程度上掩盖了差异，在必要时简化了从一个体系结构到另一个体系结构的更改，或者支持不同产品的混合体系结构。

### **2.3 SoC方式**  

在SoC方式中，一个单一的芯片，例如无线壁虎(efr 32™)组合中的ICS之一，提供所有堆栈功能(包括集成的flash、ram和rf收发器)以及应用层组件(应用程序配置文件、集群、协议管理和堆栈交互)。堆栈功能实现为预编译库文件，然后，您必须在最后的构建过程中与您自己的应用程序相关代码一起链接，以生成一个单一的、单块二进制映像，该映像包含了一个功能齐全的无线应用程序所需的一切。应用程序框架，虽然是由硅实验室提供的，但被认为是应用层的一部分。

注意：虽然引导加载程序通常用于已部署的无线网络设备，但引导加载程序固件并不是这个单芯片二进制映像的一部分。然而，Silicon Labs 提供可用于将应用程序固件和堆栈固件进一步组合为单个十六进制记录文件的后期构建工具，以便于分发和制造。有关EmberZNet pro应用程序的这些软件实用程序的更多信息，请参阅文档ug 107：em3x实用程序指南、ug 162：简单指挥官参考指南和文档ug 103.6：应用程序开发基础：引导。在soc开发方法中，应用程序(包括应用程序框架)与堆栈共存。应用程序调用由堆栈库提供的API(应用程序编程接口函数)，堆栈触发器处理函数由应用程序代码嵌入。当应用程序框架用于应用程序设计时，该框架处理调用这些API并实现必要的处理程序函数，然后将这些函数封装在更高级别的API和应用程序回调中，以实现设计过程，并帮助确保协议遵从性。

由于SoC模型只需要一个芯片，与需要多个ICS的NCP模型和遗留设计体系结构相比，SoC模型具有更低的功耗、更低的BOM(物料清单)成本和更小的可能布局。此外，当所有东西都驻留在单个芯片上时，可以与堆栈软件和无线电硬件进行更紧密的集成，从而能够更精确和及时地控制与堆栈活动相关的应用程序行为。

但是，一旦您应用了SoC模型，您就会受到SoC家族中可用产品的约束。这些措施包括：

* 闪存和内存约束
* 工具链约束，例如ZigBee和基于线程的soc使用iar嵌入式工作台的要求。
* Hal约束，例如某种类型的有限数量的外围设备，或者缺少可能是硬件设计不可或缺的专用外围设备。
* 基于必须与堆栈共享CPU的定时约束，堆栈有自己的一组需求，以维护IEEE802.15.4和协议遵从性

   **如果这些限制中的任何一个都具有威慑作用，那么NCP模式可能是一个更有吸引力的替代方案。**

### **2.3 NCP方式**  

> 注：本节不涉及蓝牙SoC或NCP模型。有关更多信息，请参阅an 1042：在网络协处理器模式下使用硅实验室蓝牙堆栈和ug 136：硅实验室蓝牙\c应用程序开发人员指南。

在NCP方式中，具有集成FLASH、RAM和RF收发器的硅实验室芯片通过具有运行时可配置性的预加载协处理器固件自行运行大部分堆栈功能，然后使用串行接口(如串行外围接口(SPI)或通用异步接收/发射机(UART)与第二个设备(称为“主机”处理器)通信，其中应用层功能与核心堆栈组件分别“托管”。ncp可以是一种特殊的集成电路，设计有限的I/o，并且减少了作为协处理器的功能，或者它可能是一个功能齐全的微控制器，它碰巧将协处理器固件加载到它上，使它作为ncp运行。

为了方便应用程序的主机和堆栈的NCP之间的通信，硅实验室提供了两个串行命令集。第一种称为ezsp(EmberZNet串行协议)，用于开发ZigBee解决方案(请参阅文档ug 100：ezsp参考指南，以获得有关ezsp的更多信息)；第二种称为Thread Management Serial Protocol (TMSP)，用于开发线程解决方案。在硅实验室FlexSDK中找到的硅实验室连接堆栈也提供了NCP解决方案，用于专有开发。

ezsp可以在spi上同步运行，也可以在uart上异步运行(无论是否有流控制)，它使用ezsp特定的命令帧(有时可能与emberz-net中基于soc的对应程序)和带有回调响应帧的Emberznet相关处理程序函数来模拟emberz-net pro api。 Silicon Labs提供ezsp驱动程序源代码，将这些串行命令和响应抽象为一组API和处理程序函数，类似于SoC模型中使用的API和处理函数。当应用程序框架用于实现应用程序层时，它负责调用必要的API函数并实现所需的处理函数，允许设计器使用客户端API和框架回调将重点放在更高级别的应用程序处理上。

在tmsp协议中，也可以在spi和uart变体中使用，主机端API并不是专门的函数，它与基于SoC的线程应用程序使用的API“类似”。相反，它们实际上与基于SoC的系统上使用的API和回调完全相同，提供的tmsp驱动程序代码处理对主机端接口的抽象。此外，tmsp驱动程序还结合了一些功能来管理NCP上的底层IP层，以改善跨NCP及其主机共享的堆栈高层之间的协调。

NCP平台的主要优势是灵活性。主机处理器可以像8位微控制器一样简单，也可以像64位计算机一样复杂，有千兆字节的内存和Windows或Linux操作系统。这意味着NCP设计非常适合于在现有系统上添加或改造设备的情况，以便利用OEM在软件和硬件方面的专门知识和知识产权来加快设计周期并加快上市时间。NCP方法的另一个优点是，与可用的SoC选项相比，主机可以为应用程序提供更多的资源(Flash和RAM)和不同的外围设备集。这允许开发更复杂的应用程序。

将堆栈处理与应用程序分离，可以通过对NCP的简单固件更新在堆栈端安装补丁和新功能，而不一定需要对主机上的应用程序固件进行任何更改。这种解耦还消除了与堆栈共享处理器的CPU时间限制。由于NCP固件管理NCP的睡眠状态以最小化其活动和当前消耗，因此只有当应用程序有不直接涉及堆栈的任务时，只有主机处理器需要处于活动状态。如果主机处理器的活动电流消耗低于cpu处于活动状态时的soc，则主机和ncp在运行非网络应用程序任务时所消耗的总电流实际上可能很低。

NCP方法的主要缺点是增加了第二个主机和处理器，这增加了额外的成本和PCB实际成本，并可能影响设备的整体功耗。另一种折衷方法是，解耦堆栈和应用程序处理意味着堆栈和应用程序之间的某些时间敏感的交互不再能够“实时”发生，而必须以通知堆栈在事实发生后所做的决定的形式出现。因此，当某些决定出现时，主机应用程序决定其结果的机会较少。相反，在NCP上配置了“策略”来指导这些情况下的堆栈行为。另外，由于ncp固件是由硅实验室提供的预构建固件，应用程序设计人员会丧失对堆栈的行为和内部资源分配方式的某种控制。

一旦您承诺使用NCP方法，您就必须决定在设计中使用哪个主机平台。这个平台在原型设计和最终设计阶段可能有所不同，这取决于材料的可用性和调试初期所需的灵活性。在选择主机平台时，请考虑您现有的专业知识以及该平台上可用的工具和资源，该平台的成本和功耗需求，以及可用于应用程序开发的内存量，包括未来增强所需的任何空间。在开发ZigBee解决方案时，还应考虑使用uart还是spi进行ezsp通信。ezsp-UART需要一个更复杂的驱动程序，通常用于兼容POSIX的操作系统中，与ezsp-SPI驱动程序相比，它具有更复杂的逻辑和更大的内存占用，而且其支持的最大吞吐量也没有那么高。然而，ezsp-SPI实现比ezsp-uart设计需要更多的接口引脚。(支持ezsp的可移植操作系统接口(POSIX)兼容的SPI驱动程序也可用，但与兼容POSIX的UART驱动程序相比，它在嵌入式Linux操作系统中的可移植性往往更低。)由于并非所有的微控制器或操作系统都支持SPI，主机上的体系结构约束可能决定了这种设计选择。 Thread 的tmsp对于SPI和UART也有类似的折衷。有关设置线程主机SPI驱动程序的更多讨论，请参见912：SPI主机接口指南。


### **2.3 设计差异**  

> 注：本节不涉及蓝牙SoC或NCP模型。有关更多信息，请参阅an 1042：在网络协处理器模式下使用硅实验室蓝牙堆栈和ug 136：硅实验室蓝牙c应用程序开发人员指南。

下表按功能显示了SoC应用程序和基于NCP的主机应用程序之间的一些主要区别。





| 场景 | Soc | NCP |
|:-------------:|:-------------:|:-----------:| 
| **管理堆栈参数**<br>(如表大小和分配限制)和端点描述符数据(如支持群集和配置文件)。 | 主要通过编译时的定义来设置，静态内置到应用程序二进制中 |由NCP管理，但由主机在NCP启动后并在进行任何网络活动之前在运行时配置；此间隔称为“配置”阶段，允许在不重建固件的情况下对NCP进行动态配置。 |
| **事件应用反应** | 应用程序可以对事件做出反应，例如安全身份验证请求、来自子节点的传入数据轮询或远程绑定修改，并且可以逐案处理事件。 |主机应用程序提前将策略配置为预先阻止-挖掘结果；通知是事后通知。 |
| **轮询**<br>(对于需要定期轮询网络的休眠终端设备)，应用程序框架负责轮询状态机，因此当使用轮询状态机时，两者之间的差别可以忽略不计。 | 应用程序控制每次轮询发生的时间，并选择如何对每次轮询的结果作出反应。 | 主机应用程序配置轮询率和故障容忍度。NCP使用配置的速率处理轮询，并且只在故障率超过配置阈值时通知主机。如果不使用应用程序框架，这可以使主机平台上的应用程序状态机设计更容易。 |
| **管理消息缓冲区**<br>应用程序框架处理SoC缓冲区管理，所以当使用它时，差别是可以忽略不计的。 | 应用程序与堆栈共享数据包数据的内存。共享消息缓冲区必须由应用程序为传出消息数据分配，并由堆栈为传入或中继消息数据分配。缓冲区管理过程，包括缓冲区的分配/去分配和构造，可能是棘手的，并且常常是SoC应用程序设计中的错误来源。 | NCP处理缓冲区管理本身，并接受/传递消息有效负载数据作为一个简单的数组和一个长度参数。这使得消息传递接口更简单，如果不使用应用程序框架，则不太容易出错。 |
| **处理ZigBee源路由**<br>其中应用程序将处理传入路由记录通知，并将此数据保存在“源路由表”中。 | 源路由表驻留在SoC上；其大小受SoC有限的RAM资源的限制。 |NCP可以在自己的内部源路由表中收集最后n个源路由，其中n在配置期间由主机应用程序调整大小。但是，主机接收来自NCP的回调中的路由记录数据，并且根据主机的ram约束，通常可以缓冲比NCP多得多的路由数据。这使得在NCP平台上的高ram集中器操作(通常用于网关、COM退出/配置工具和其他主要聚合点)比在SoC平台上更可行，特别是在那些RAM可用性有限的SoC平台上。 |
| **添加和删除核心网络和无线电功能** | 更改SoC应用程序中的核心(堆栈)功能时，只需从单个应用程序中添加或删除库或源代码。通过更改要包含的插件，使用应用程序框架很容易做到这一点。 | 如果要更改主机中的核心(堆栈)功能加上NCP应用程序，则必须对主机进程或应用程序以及NCP固件进行更改。这可能会对应用程序开发过程造成轻微的阻碍，但是网络代码-SOR应用程序框架可以对此有所帮助。此应用程序框架提供了一个构建ncp应用程序的接口，该应用程序只包含选定的核心网和无线电功能。 |


## **3. ZigBee设计选择(Zigbee Design Choices)** 
 
尽管应用程序框架简化和抽象了设计过程，但无论设计是否基于应用程序框架，一些设计决策都必须作为集成的一部分进行。在开发ZigBee协议的应用程序(包括ZigBee pro和ZigBee RF4CE)时，适用下列设计选择:

- 单网或多网(Single Network or Multi-Network)
- 网络发现/调试方法(Network Discovery / Commissioning Method)
- 设备发现和配置方法( Device Discovery and Provisioning Method)
- 路径建立方法(Route Establishment Method)
- 信息传递方法(Message Delivery Method)
- NCP与主机应用程序兼容性( NCP and Host Application Compatibility)  

### **3.1 单一网络与多网络**  

单个网络节点是形成或连接一个网络的节点，在形成或加入第二个网络之前必须离开该网络。EmberZNet PRO 4.7引入了节点同时参与多个网络的可能性(em351不支持此特性)。


> 注：对于EmberZNet Pro，多网络支持仅限于两个网络.未来可能支持两个以上的网络。

到目前为止，任何设备都需要两个物理芯片作为两个网络的一部分。例如，设计成在HA(家庭自动化)PAN(个人区域网络)和Se(智能能源)PAN之间的网关的设备将使用第一芯片和使用第二芯片连接第一网络。应用程序必须管理两块硬件，从而增加了硬件和应用程序设计器的复杂性。

多网络堆栈移除逻辑盘和物理芯片之间的1到1映射，将其扩展到n到1映射.对于带有单一芯片的设备的应用程序可以设计为多个PAN的一部分，可能运行不同的安全配置文件(用于临时的HA和Se)。使用一片而非两片芯片可以节省成本，减少硬件需求，降低硬件和应用程序代码设计的复杂性。

一些应用程序仍然需要双芯片配置。如果设备需要在两个网络上充当协调器或路由器(请参阅下面的详细信息)，或者如果应用程序需要在两个不同的堆栈上操作，如EmberZNetpro和Sili-con Thread，则需要这种配置。

一个芯片上的多个网络是通过在网络上共享芯片的唯一无线电来实现的。换句话说，多网络节点根据网络调度算法重置网络之间的所有无线参数。

节点在多个网络上同时处于活动状态这一事实对应用程序是完全透明的。API允许应用程序指定引用一组API调用的网络。类似地，API允许应用程序了解堆栈回调与哪个网络相关。有关双网络API的更多详细信息，请参阅文档AN 724，为单个芯片上的多个网络设计。

afv 2和网络协处理器应用框架都提供了双重网络支持。我们强烈鼓励在开发双网络应用程序时使用应用程序框架。应用框架在减少复杂性方面提供了许多优势，主要与框架如何无缝地管理不同的网络上下文有关。

通常，当需要在特定网络上发送传出数据包时，多网络堆栈切换网络，或在不同网络上重新调整无线电。在非传输时间内，根据堆栈的内部网络调度算法，无线电总是在其中一个网络上进行调谐。

对于节点可以在网络上扮演的角色有一些限制。由于协调器或路由器节点需要保持无线电不断监听传入的数据包，因此多网络节点只能是一个网络上的协调器或路由器，而它必须是另一个网络上的休眠终端设备。

> 注意：节点可以在一个网络上承担任何角色，但必须是另一个网络上的一个休眠终端设备。

节点参与的网络可以是不同的信道、不同的PAN ID、不同的短ID、不同的配置文件等。然而，多网络节点在其参与的网络中维护相同的eui 64地址。下一节将更详细地讨论两种基本配置，第一种是多网络节点在一个网络上是协调器或路由器，在所有其他网络上是一个昏昏欲睡的终端设备，第二个配置是所有网络上的休眠终端设备。

#### **3.1.1 协调器/路由器网络休眠终端设备网络**  

一个多网络节点是一个网络上的协调器/路由器，而另一个网络上是一个昏昏欲睡的终端设备，它应该把大部分时间花在协调器/路由器网络上。一种网络调度算法可以无缝地处理从一个网络切换到另一个网络的问题，这样，除了短时间外，节点总是在协调器/路由器网络上。特别是，该节点暂时离开协调器/路由器网络以完成休眠终端设备网络上的某些事务，例如从父节点和/或发送给父节点的轮询/数据检索。这些事务通常在应用层启动。因此，应用程序设计人员应该设计应用程序，这样节点就不会花费太多时间离开coordina。

在为单片芯片上的多个网络设计的文档AN 724中，硅实验室提供了从广泛的实验中获得的数据，这些数据显示了一些典型的轮询和沉睡的终端设备与其父设备之间的数据事务的平均持续时间。该文档还详细研究了休眠终端设备网络上的活动如何影响协调器/路由器网络的吞吐量。使用这些数据，您可以根据多个网络节点在沉睡的网络上将处理的流量以及这些流量如何影响协调器/路由器网络的性能来做出有意义的设计选择。

请注意，即使节点在大多数网络上表现为一个休眠的终端设备，如果它也是任何一个网络上的协调器/路由器，它也无法通过暂时关闭无线电(睡眠模式)来节省能源。

#### **3.1.1 协调器/路由器网络休眠终端设备网络**  

在所有网络上，一个多网络节点是一个沉睡的终端设备，它不需要总是开着它的收音机。节点可以在每个网络上以不同的投票率轮询。只要在任何网络上没有活动，节点就能够休眠。任务包括帮助确保设备可以加入适当的网络或从某些外部源接收所需的网络设置，以及确保当错误的网络被错误地连接到或设备被迁移到新的安装时，设备可以从网络中被移除。同样，如果您正在设计一个可以充当ZigBeePAN协调器的设备，那么重要的是要考虑如何简化那些希望进入协调器网络的设备的网络选择过程。



### **3.2 网络发现和调试**

调试是指设备进入网络的过程。如果您阅读了在文档ug 103.2：应用程序开发基本原理：ZigBee中对网络连接过程的讨论，您可能还记得，除非设备充当PAN的协调器，否则它必须请求加入现有网络，并且连接设备必须扫描一个或多个通道来定位可用的网络。但是，由于网络协调器在形成PAN时有几个无线信道可供选择，而且由于网络的PAN id和扩展PAN通常是随机的，因此您的应用程序通常需要一些智能或外部机制来协助网络发现和调试。

注意：如果您正在设计一个正式的、公共的ZigBee Pro应用程序配置文件(如家庭自动化)中使用的应用程序，硅实验室建议您检查最新发布的适当ZigBee应用程序配置文件规范的修订版(可以从http：/www.zigbee.org获得)，以确保它满足COM-错误控制的任何特定配置文件要求或最佳做法。

#### **3.2.1 通过扩展的PAN id或信道掩码简化网络选择**

虽然由PAN的协调器进行的扩展PAN id选择通常是随机的，但是专有网络部署可以使用扩展PAN ID的spe-ciical位掩码作为增强连接设备的网络选择的一种方法。在此模型中，协调器在此商定的扩展PAN id掩码内形成网络，这样连接设备可以扫描通道以寻找打开的PAN，并限制配置的扩展PAN id范围之外的通道。但是，这种增强网络选择的方法对于希望在公共ZigBeePro配置文件上与来自广泛制造商的设备进行互操作的设备来说是不可行的。由于公共ZigBeepro应用程序配置文件通常不限制其扩展PAN id选择，因此另一个供应商的设备可能占用您选择的限制位掩码的外部扩展PAN ID。

类似地，尽管2.4GHz ZigBee网络可以占用16个不同信道中的任意一个，但连接设备可以限制其通道掩码扫描。预期的网络可能是一种专有设计，在这种设计中，协调器选择将其信道选择限制在预先配置的掩码内的少数几个信道上。或者，所包含设备的一个或多个端点所基于的应用配置文件可能需要将网络的信道选择限制在特定的信道集上。例如，ZigBeePROSE和HA应用简档都要求在形成网络到最常用的Wi-Fi信道分配(IEEE802.11范围中的信道1、6和11)之外的信道时给出优选，这允许连接设备将其信道扫描限制到ZigBee信道11、14、15、19、20、24和25。注意，AFV2使用网络查找插件(如果已启用)在连接或形成网络时配置设备的信道掩码。如果使用应用程序生成器来配置应用程序，请确保检查网络查找插件的配置对话框中的通道掩码和其他无线参数设置。如果您没有使用网络查找插件，或者您的应用程序不是基于afv 2，则您的应用程序代码需要使用自己的方法来确保在网络扫描、连接或形成过程中强制执行首选通道掩码和任何其他首选网络参数。


#### **3.2.2 许可证连接控制**

希望加入网络的设备通常只考虑那些对新设备开放的PAN(换句话说，它们允许加入)，设备不能永久设置其许可连接标志，这样做可能会导致公共配置文件和制造商专用配置文件(Msp)的ZigBee Pro遵从性测试失败。因此，当需要向网络中添加新设备时，设备，特别是PAN协调器，必须确保它们能够在本地至少在有限的时间内实现允许连接标志。这种支持一般必须来自某种外部刺激，这将取决于设备的物理能力。如果一个按钮或串行接口是可用的设备，这通常是一个适当的刺激，以使许可连接。但是，如果设备没有外部输入作为此刺激，则必须考虑其他方法。一种可能性是，当设备第一次启动时，允许它在有限的时间内进行许可连接。另一种选择是，当节点通过空中接收到特定的消息时，使允许发送连接。

关于后一种方法，虽然应用程序可以通过本地调用emberpermitjoin()api或permitjoin ezsp命令对其自己的permitjoin状态进行本地更改，但也可以通过zdo(ZigBee Device对象)向ZigBee节点发送标准请求(ZigBee Device对象)，该zdo本质上是由堆栈实现的，ZigBee节点要求它更改其允许的加入状态。当在应用程序配置文件0x0000(ZigBee设备配置文件)上通过空气接收到端点0(Zdo)的Zdo允许加入请求时，堆栈会自动更改设备上的许可证连接状态。此请求的单播或广播分别为一些或所有设备提供了远程更改网络连接权限的标准方法。有关实现此请求的示例代码，请参阅EmberZNet Pro安装中的“app/util/zigBee-framework/ZigBee-DeviceCommon.h”文件中的emberpermitJoingRequest()API。

一旦网络在允许连接的连接设备的范围内包含至少一个节点，该连接设备就应该能够通过堆栈的本机embernetwork芬兰处理程序()/ezspnetwork芬兰处理程序()回调或在app/util/public/form-and-job.h中找到的表单和连接实用程序提供的窗体-和连接实用程序提供的emberj oinablenetworkound处理程序()回调来检测它是否可连接。(有关推荐的实现，请参阅afv 2的“网络查找”插件或“网络指导”插件。)

#### **3.2.3 避免调试过程中的意外后果**

一旦您的连接设备确实找到一个可连接的网络并试图加入它，应用程序或安装程序必须确定它是否是“正确的”网络，这意味着在范围内并允许连接的是预定的网络，而不是其他任意的PAN。连接和随后的身份验证过程涉及获取当前pan的nwk(网络)层加密密钥，即使在加入预期的网络时，也可能以多种方式失败。因此，永久排除试图连接但已发生连接/身份验证失败的网络并不一定是最佳实践。类似地，取决于您的连接设备的安全期望，它可能成功地加入一个根本不正确的网络，因此永久地稳定在网络中，仅仅是因为堆栈发送了EMBNETAN_UP信号，指示设备已成功地被连接和身份验证到网络中，这也是不够的。确定尝试网络是否正确的适当标准根据您的设计需求而有所不同，特别是在安全性方面。

如果您正在设计用于ZigBee Prose(智能能源)网络的设备，则需要一个复杂的预授权过程才能成功地进入网络。有关更多信息，请参阅文档ug 103.5：应用程序开发基础：安全性。假设目标网络中已经满足了预先授权的要求，那么意外地加入错误的网络应该是不可能的，因为如果NWK密钥以不同的APS(应用程序支持)链接密钥到达未加密或加密，则连接设备将不接受NWK密钥传递。

然而，即使使用se安全模型，连接节点可能仍然需要考虑这样一个事实，即不可靠的链路或其他通信问题，特别是如果涉及到PAN的信任中心，甚至在正确的网络中，也可能导致来自信任中心的NWK密钥的传递失败。因此，如果检测到一个可连接的网络，但随后的连接和身份验证失败了，那么成员_NON_KEY_INDEL(意味着NWK键没有成功到达)、EMBJOIN_FILE(这可能意味着连接的关联响应未被成功接收)或EMBNO信标(这意味着所选网络上的关联请求无法得到一个答案)，您可能想要重新尝试在该节点上的连接过程，或者立即重新尝试连接过程。如果连接或身份验证过程在所选的PAN上继续失败，请考虑尝试加入另一个可连接的网络，只要您的设备可用，因为失败可能表明这是一个简单的错误网络。

在使用带有用于传递随机生成的NWK密钥的公用预先配置的APS链接密钥的HA(Home Automatic)安全模型的网络中，如果在连接设备的范围内碰巧存在多个可连接网络，则意外地加入错误网络的风险很大，因为这些网络之间的安全设置对几乎所有ha网络都是公共的，而不是对每个传入节点是唯一的。请注意，HA网络可以使用不同的预先配置的链接密钥，但在新节点加入网络之前，必须以某种方式将该密钥传递给新节点。因此，您应该在应用程序设计中格外小心，以确保一旦您成功地进入一个PAN，它确实是预期的。这通常涉及到接受设备的每个可用网络的某种“连接和验证”过程，这意味着发送某种定义良好的空中消息，并期望响应指示正确网络的加入；这种响应可能是另一种空中消息，或者是系统另一部分的某种可检测的行为。

下表描述了每种方法的示例，从一个新节点加入候选网络开始：
                  
**连接和验证方法**

![](https://github.com/XuBinTan/Silicon-LABS-EFR32MG12-/blob/master/Silicon%20Labs/EFR32MG/photo/Slicon%20UG103.3%20table3.1a.jpg)

![](https://github.com/XuBinTan/Silicon-LABS-EFR32MG12-/blob/master/Silicon%20Labs/EFR32MG/photo/Slicon%20UG103.3%20table3.1b.jpg)



上述方法之一的选择，或其中的某些变体，很可能取决于系统中设备的能力、多厂商互操作性在设计中的重要性、调试过程的预期延迟以及将要调试设备的安装人员的复杂程度。

ZigBee在zcl中提供了一个调试集群，这有助于在空中将某些调试参数安装到设备中。但是，到本文编写时，HA和Se配置文件都不需要在客户机或服务器端实现该集群的设备类型，也没有将其作为ZigBee互操作性测试事件的一部分进行测试。只有在网络中才能使用调试群集，这样才能确保连接节点具有对调试群集的服务器端支持，并且系统中至少有一个设备具有发送调试命令的客户端支持。此外，由于调试群集依赖于ZigBee消息，这需要在第一个位置处于网络中，因此您需要设计一个方案，使您的设备加入一个可以提供必要参数的调试工具的临时调试网络。虽然应用框架允许使用ZCL的调试集群，但是如果需要，该集群的实现是应用开发者的责任。

#### **3.2.4 断开机制**

许多设计者在网络选择过程中进行了仔细的思考，而忽略了为系统从当前网络中卸载设备并将其安装到一个新的网络中提供了一种方法。如上面的试运行示例所示，使设备能够以某种方式手动或自动启动一个emberlevenetwork()操作，并在断开完成后可能找到一个新的网络，通常是便利ZigBee设备在其预定网络中成功安装和重新安装所必需的。

如果不能在连接设备本身的硬件或软件中实现这一点，则由堆栈自动执行的zdo离开请求机制可能是可行的选择，因为它允许PAN中的另一个节点，例如网络控制器，指示设备离开网络。有关实现zdo离开请求命令的示例代码，请参阅EmberZNetpro安装中的“app/util/zigbee-framework/zigbee-device-common.h”文件中的emberleaverequest()API。

### **3.3 设备发现和配置**

一旦你将你的设备加入到正确的网络中，它就需要与提供相关服务的PAN中的其他节点配对(换句话说，客户端设备与一个或多个服务器端设备成对)。这种将PAN中的相关设备配对起来以便在应用程序级别进行通信的过程称为“供应”。相反，“委托”处理在网络堆栈级别上将设备关联在一起进行通信的问题。当您设计您的设计时，请考虑如何发现您的PAN中的哪些设备和多少设备提供感兴趣的服务(集群)，以及以何种方式将这些相关设备提供给对方。注意，实际的供应过程通常以一个或多个涉及的设备结束，每个设备都将伙伴设备注册到其绑定表、其地址表或一些定制存储机制中，以便能够将消息发送到该目的地。


#### **3.3.1 何时发现和提供**

通常，应用程序设计人员设计他们的应用程序来执行某种类型的设备发现，并试图在设备的调试过程完成后(也就是在设备上线后不久)提供服务。但是，由于设备一次连接一个，这意味着供应的一方通常在另一方之前联机，因此您可能需要一种由软件状态机逻辑、外部中断或一些空中刺激启动的机制，以便在设备在网络中的后期启动配置。

下一节将介绍不同的配置方法，各节各有优缺点。

注意：如果您正在设计一个正式的、公共的ZigBee pro应用程序配置文件(如ZigBee 3.0)中使用的应用程序，硅实验室建议您检查最新发布的适当ZigBee pro应用程序配置文件规范的修订版(从http：/www.zigbee.org获得)，以确保您的设计满足任何特定于配置文件的要求或最佳实践。

#### **3.3.2 识别分组法**

此方法可用于一对一的配置或一对多的配置，在单个源设备(通常为所提供的群集的客户端)和一个或多个目标设备(通常为所提供的群集的服务器)之间使用。它包括通过接收来自某个设备的识别命令或通过某些外部刺激将每个目标节点置于标识模式。然后，源节点作为广播发送一个“Add group if标识”命令(zcl的标识集群中所需的客户端命令)，以便当前处于标识模式的所有节点通过zcl组服务器集群维护的Groups表将自己添加到指定的组中。一旦目标设备属于单个组，源设备就可以直接向组发送多个广播(emberoutgoingmessagetype的成员_传出_Direct)，或者为目标组创建多播绑定，然后通过该绑定发送传出命令(成员_传出_VIA_Binding)。

益处：

- 允许同时向多个目标提供单个设备。
- 如果所有目标设备都支持处于标识模式的本地方法，则只需要一条空中消息(添加组，如果标识命令)。
- 可以在很长或很短的时间间隔内执行，因为标识命令中使用的标识时间可以设置得非常小或很大。
- 可以使设备进入标识模式，以便在需要时可以在空中以这种方式提供设备，因此可以在没有本地刺激(按钮或其他用户界面)的设备上工作。
- 如果不能让源节点手动发送Add组(如果识别命令)，则可以将源节点放入标识模式并添加到组中，以便自动创建多播绑定(作为组表逻辑的一部分)，用于与目标通信。


短处：

- 目标设备必须支持组服务器并识别服务器群集。
- 目标设备可能需要本地刺激，例如按下按钮进入识别模式，除非系统中的另一个设备被告知向感兴趣的特定设备发送识别命令。

#### **3.3.3 按钮法**

该方法包括在一个或多个设备上按一个按钮，以使得它可以发射一个消息，该消息可以将其他设备REC-OGNED作为一个信号，以适当地与该设备进行供应，或者进入一个状态，在该状态中在特定时间窗口内接收特定消息使其与发送方进行供应。例如，需要连接到一个或多个灯的灯开关可以使用按钮按下进入一个状态，在接下来的30秒中，由灯光发送的任何“添加到切换”消息都会导致该开关为这些灯注册一个绑定条目。类似地，按下按钮(或其他刺激)可以使这些“添加到切换”的信息被每一盏灯传送。

益处：

- 在实现方面有很大的灵活性，比如按下按钮上的操作以及某些配置状态持续多长时间，这反过来会影响到允许配置过程所需的时间。
- 可用于一对一或一对多的配置。
- 不需要任何第三方设备(那些不在供应过程的任何一方)的参与。
- 允许用户/安装程序通过手动交互显式控制资源调配过程。
- 不需要任何特殊的集群支持。
- 可以与涉及手动交互的其他配置方法(例如标识和组方法)一起使用。

短处：

- 供应的一方或双方都需要本地刺激(如按钮)才能参与此过程。
- 可能涉及专有消息传递协议(例如，上面示例中讨论的专有“添加到切换”消息)或特定于应用程序的行为，从而降低了供应商之间互操作性的可能性。
- 如果同时发生多个配置过程(例如，如果多个安装程序同时在同一网络上执行按钮配置)，则可能发生错误设备之间的配置。

#### **3.3.4 匹配描述符请求方法**

在这种方法中，寻找用于供应的特定合作伙伴的设备通过zdo匹配描述符事务查询一个或多个节点，以便根据其他节点的描述符信息(应用程序配置文件、设备标识符、群集ID和客户机/服务器支持)为每个端点查找合适的供应伙伴。在涉及该方法的典型方案中，在应用简档Y上配置的用于特定集群(集群X)的客户端设备向网络发送ZDO匹配描述符请求，其中描述符信息指定具有用于在简档Y上的集群X的服务器支持的端点。接收该请求的所有节点自动使用在每个标准ZigBeePRO栈中构建的代码来处理消息，通过尝试将所查询的端点描述与在其自身端点之一上的端点描述符匹配。如果被查询设备上的一个或多个端点与所请求的条件匹配，则被查询设备用包含与请求匹配的端点列表的单播zdo匹配描述符响应进行响应。然后，执行查询的设备可以解析响应，并决定它应该为自己提供哪些(和多少个)伙伴。

益处：

- 提供基于特定群集支持条件集的配对。
- 不需要第三方的交互来促进配对(与终端设备绑定方法相比)。
- 使用标准的zdo框架进行查询和响应，允许在不需要对查询和响应进行特殊解析的情况下实现可互操作的解决方案。堆栈自动处理zdo查询。
- 查询可以广播或单播。

短处：

- 通常依靠广播来查找所有节点，这并不是100%可靠的，并且消耗了网络带宽。
- 当作为广播发送时，zdo匹配描述符请求只能发送到在空闲时RX上的广播地址，这意味着使用此方法无法发现休眠(在空闲时关闭)终端设备。
- 应用程序需要一些内部逻辑或用户界面来评估查询应答者，并决定自己应该提供哪些设备和设备。
- 匹配描述符响应可能不包含发送方的eui 64，因此基于长地址(而不是动态的16位节点ID)的配置可能需要额外的单播zdo ieee地址请求事务来查询合作伙伴节点的eui 64。


#### **3.3.5 简单描述符请求方法**

简单描述符请求方法类似于匹配描述符请求方法，因为它使用标准zdo查询来查询目标节点的端点配置(概要文件、集群、服务器/客户端支持等)。但是，如果匹配描述符请求作为广播或单播发送，以尝试在接收设备上匹配群集支持条件，则简单的去脚本请求仅作为单播发送到目标节点的特定端点，并生成目标端点上可用的支持客户端和服务器群集的完整列表。此请求可在目标节点的每个可用端点上迭代使用，以发现跨端点可用的所有可能的集群支持。zdo活动端点请求经常用作zdo简单描述符事务的前身，以便查询设备能够知道目标节点存在多少有效端点及其端点号。虽然这种方法比匹配描述符请求方法产生更完整的信息，但是它的效率也较低，因此在需要查询大量设备时使用通常是不实际的。当查询设备不确定它应该在目标设备中提供哪些集群时，这种方法最有用；一旦它知道伙伴设备上有哪些集群可用，它就可以在完成配置过程时从这些集群中进行选择。


益处：

- 提供基于特定群集支持条件集的配对。
- 不需要第三方的互动来促进配对。
- 使用标准的zdo框架进行查询和响应，允许在不需要对查询和响应进行特殊解析的情况下实现可互操作的解决方案。堆栈自动处理zdo查询。
- 不依赖广播机制。
- 不要求查询设备知道目标设备上需要哪些群集。


短处：

- 需要大量的来回事务(每个端点一个命令/响应事务，再加上一个用于活动端点请求来评估可行的端点号)来发现目标的端点数据。虽然这些事务的带宽消耗相对较低，但完成供应过程的延迟可能很大，特别是当目标上有多个端点时。
- 应用程序需要一些内部逻辑或用户界面来解码要查询的节点以及当响应数据到达时该如何处理。
- 简单的描述符响应可能不包含发送方的eui 64，因此基于长地址(而不是动态的16位节点ID)的配置可能需要额外的单播zdo ieee地址请求事务来查询合作伙伴节点的eui 64。注意：当请求是启用源eui 64 APS选项的单播时，许多设备将在zdo响应中包含他们的eui 64，这是EmberZNetpro堆栈的默认行为。


#### **3.3.6 供应工具法**

在这种方法中，第三方设备(不是所提供的节点之一)获取关于网络中的一些或所有设备的信息，然后提供用户界面，以允许网络的安装程序/管理员以他认为合适的方式相互提供设备。该设备信息可以通过上述部分中描述的zdo发现过程之一(简单描述符请求或匹配描述符请求)或通过一些更专有的手段(类似于设备广告方法中的网络集中器提供设备信息的方式)来获取。

供应工具可以是专用于此角色的设备，也可以是网络中的其他中心角色，例如网络集中器、PAN协调器、调试工具或网关。由于供应工具可能与网络中的许多不同设备进行通信，因此硅实验室建议将此节点作为网络集中器来运行，这样就可以很容易地获得到其他节点的路由，而无需进行一系列路由发现，这会增加网络负担并增加延迟。

一旦工具决定了应该向对方提供哪些设备，它通常会使用对目标设备的zdo绑定请求来安装绑定表条目，以便与合作伙伴设备进行通信。

益处：

- 提供基于用户输入的配对，以便在配置方面具有最大的灵活性。
- 在提供的设备中，除了标准的zdo支持之外，不需要任何用于信息发现的智能。所有智能驻留在供应工具节点中。
- 配置设备不需要唤醒就可以进行自己的配置，因此当其中一个配置设备处于休眠状态时，就可以进行配置过程。
- 当新节点进入网络时，设备不需要担心重新发现节点来提供服务，因为这个工具可以解决这个问题。

短处：

- 需要具有自定义用户界面的特殊工具(专用设备或现有设备上的一组额外功能)以方便配置。
- 供应工具需要定期从设备中收集信息，以避免与设备自身的配置行为发生冲突。



#### **3.3.7 地址发现**

由于配置通常涉及创建绑定表或地址表条目，这依赖于用于跟踪设备的eui 64，因此参与配置的节点应努力获取其合作伙伴设备的eui 64，以方便这些表输入创建。例如，当使用设备广告方法时，如果接收方选择向广告客户提供自己，则包括广告商eui 64以防止接收方随后发现这一点是有用的。作为另一个例子，当使用zdo请求方法，例如简单描述符请求和匹配描述符请求方法时，该请求应该在可能的情况下与请求设备的源eui 64相关联，以便接收机能够通过在响应帧中提供其eui 64地址来作出实物响应，从而允许更平滑的配置。

### **3.4 线路建立**

在许多网络中，大量的数据被输送到一个指定用于存储数据或将其卸载到另一个系统或网络的节点上。这种行为在大型传感器网络中最为常见，在这种网络中，从许多设备收集信息并聚集在某个中心点。

多对一路由(MTOR)允许聚合点(ZigBee术语中的“集中器”)为网络上的每个设备提供到集中器的路由，而不需要每个节点单独发现它。此外，mTOR提供了一种向集中器传送每个节点到该集中器的自己的路由的方法。这允许集中器根据自己的判断收集部分或全部这些路由记录，这是一种称为“源路由”的技术。mTOR与源路由一起工作，以允许集中器与其他节点之间的双向通信，而无需在消息传递时发现新的或更新的路由。


#### **3.4.1 背景-多对一个路由**

在ZigBee开发的早期，很明显，嵌入式无线网络应用程序中的一种常见的通信模式是多对一，其中多达数百台设备可能与中央网关通信。在硅实验室，我们有时使用术语“聚合”来指这种模式，而术语“聚合器”指的是网关节点。


#### **3.4.2 它是如何在ZigBee pro中工作的？**

本节简要介绍了ZigBeePRO网络层中现在如何指定聚合的详细信息。

集中器(例如，网关)通过发送多对一路由请求来建立路由.这只是一个普通的路由请求发送到一个特殊的广播地址。它向接收节点的网络层发送信号，以创建入站路由，而不是点对点路由。没有发送路由回复；下面描述的路由记录命令框架具有概念上类似的目的。

当设备向集中器发送单播时，网络层透明地负责首先向集中器发送路由记录命令帧。当路由记录分组被路由到集中器时，中继节点将其短ID附加到命令帧。通过存储从路由记录有效载荷中获得的路由，集中器被提供它所需的信息，以向相反的方向发送路由数据包。

源路由通过在网络帧中添加子帧和在网络帧控制字段中设置位来完成。当中继接收到时，从子帧而不是本地路由表读取下一跳。集中器上的应用程序回调在必要时将源路由子帧插入到传出的单播或APS确认中。

路由维护是通过集中器应用程序重新终止特殊的多对一条路由请求来完成的。

您可以在线API参考指南和许多常见问题解答文章中找到更多的信息，这些文章都可以在硅实验室的sup端口门户网站上找到。


### **3.5 消息传递**

本节概述本主题。如果您想要更详细的信息，请参阅文档ug 105：使用堆栈和HALAPI进行高级应用程序编程。

消息处理取决于您是使用SoC还是NCP模型，还是使用afv 2或直接EmberZNetproAPI。但是，不管模型如何，消息处理中涉及的许多细节和决策都是相似的。一般来说，消息处理分为两大任务：

- 创建消息
- 处理传入消息

EmberZNet PRO堆栈软件负责处理消息处理中所需的大部分低级别工作。下面的曲线图-跟踪应用程序在消息处理中与系统交互的位置。然而，虽然APS层处理APS帧结构，但是应用程序仍然有责任在出站消息上设置APS报头，并在入站消息上解析APS报头。

![](https://github.com/XuBinTan/Silicon-LABS-EFR32MG12-/blob/master/Silicon%20Labs/EFR32MG/photo/Slicon%20UG103.3%20F3.1.jpg)


#### **3.5.1 发送消息**

可以发送三种基本类型的消息：

- 单播-基于地址表条目发送到特定节点id(如果需要，应用程序也可以手动提供节点id)
- 广播-发送到所有设备、所有不困设备或所有非zeds(ZigBee终端设备)
- 多播-发送到共享同一个组id的所有设备。

在发送消息之前，必须构造一条消息。消息帧根据消息类型和安全级别而有所不同。由于大部分消息帧是在应用程序之外生成的，因此要考虑的关键因素是来自应用程序的消息有效负载的最大大小。

下表显示了用于发送最常见消息类型的详细API。



| EmberZNet API | Application Framework API | Description |
|:-------------|:-------------|:-----------:| 
| emberSendUnicast(<br>EmberOutgoingMessageType type,<br>int16u indexOrDestination,<br>EmberApsFrame   *apsFrame,<br>EmberMessageBuffer message) |emberAfSendUnicast(<br>EmberOutgoingMessageTypetype,<br>int16u indexOrDestination,<br>EmberApsFrame*apsFrame,<br>int8u　messageLength,<br>int8u * message <br>) | 发送单播消息，按照ZIGBEE专业规范。  |
|emberSendBroadcast (EmberNodeId destination,<br>EmberApsFrame * apsFrame,<br>int8u radius,<br>EmberMessageBuffer message<br>)|  emberAfSendBroadcast (int16u destination,<br>EmberApsFrame *apsFrame,<br>int8u messageLength,<br>int8u* message<br>)|  按照ZigBeePro规范发送广播消息。该消息将被传递到发送方半径跃内的所有节点。半径为零的值转换为EMBmax_HOPS。 |
| emberSendMulticast (EmberApsFrame * apsFrame,<br>int8u radius,<br>int8u nonmemberRadius,<br>EmberMessageBuffer message<br>)| emberAfSendMulticast(<br>int16u multicastId,<br>EmberApsFrame * apsFrame,<br>int8u messageLength,<br>int8u* message<br>)| 向共享特定多播id并位于发件人指定跳数范围内的所有端点发送多播消息。|

注意：请记住，在线API文档比这里显示的更广泛。要获得最终信息，请始终参考在线API文档。

在上述每一种情况下，消息缓冲区都包含该消息。通常，应用程序为该缓冲区分配内存(大约为32字节的倍数)。您可以动态地了解这个缓冲区的大小，这反过来决定了要发送的消息的最大大小。根据使用中的安全级别，函数embermaxumapspayloadength(Void)返回应用程序支持子层将接受的有效载荷的最大大小。这意味着：

- 构造您的消息涉及到为适当的消息类型提供参数.功能。
- 使用最大的spayload长度(Void)来确定您的消息可以有多大。
- 执行安森德.函数将导致您的消息被发送。

正常情况下，安森德.。函数返回一个值。有关更多信息，请查看在线API文档。

虽然发送消息的任务有点复杂，但它也非常一致。设计应用程序的挑战是跟踪要发送的参数值和消息。有些消息可能必须以部分段发送，而如果发生错误，则可能需要重新发送一些消息。您的应用程序必须处理这些可能性的后果。


#### **3.5.2 接收消息**

与发送消息不同，接收消息是一个更开放的过程.当收到消息时，通知应用程序，但应用程序必须决定如何处理它以及如何响应它。基于非应用程序框架的应用程序使用堆栈的泛型emberincomingmessageHandler()来接收和处理消息。基于afv 2的应用程序使用各种不同的回调函数，这些回调函数专门用于消息所表示的特定命令或响应，如emberafreadproperties responsecallback或emberafdemandresponseloadcontrolclusterloadcontroleventcallback。有关afv 2如何处理传入消息以及在您的应用程序中处理这些消息的可用回调的详细信息，请参阅文档ug 102：应用程序框架开发人员指南。

还需要注意的是，堆栈不会检测或过滤APS层中的重复数据包。它也不能保证订单的MES-SAGE送货。这些机制需要由应用程序实现。

在SoC的情况下，堆栈处理接收和存储消息的机制。但在NCP的情况下，MES-SAGE直接传递给主机.除了对消息内容作出反应之外，主机还必须处理接收和存储消息。

在所有情况下，应用程序都必须将消息解析为其组成部分，并决定如何处理这些信息。注意，作为应用程序的一部分，应用程序框架执行大部分消息解析。应用程序框架仍然给予应用程序开发人员完全的灵活性和对消息接收处理的控制。消息一般可以分为两大类：命令消息或数据消息。命令消息涉及作为网络功能成员的目标的操作(包括内务管理命令)。数据消息是向应用程序提供信息的，尽管它们可以处理连接节点的设备的功能，例如温度传感器。

#### **3.5.2 确认消息**

当收到消息时，确认收到消息是一种很好的网络协议。这是在Mac层的堆栈软件中使用链接ack自动完成的，不需要应用程序执行任何操作。下图显示节点a向节点d发送消息。

![](https://github.com/XuBinTan/Silicon-LABS-EFR32MG12-/blob/master/Silicon%20Labs/EFR32MG/photo/Slicon%20UG103.3%20F3.2.jpg)

当交付过程完成时，应用程序将收到回调。回调根据ACK的接收或缺失表示传递的成功或失败，如果请求，则选择APS[端到端]ack；如果没有，则指示mac[链接]ack。)因此，开发人员可以读取交付过程的成功或失败，并可选择地在应用程序级别重试交付(如果需要的话)。

### **3.6 NCP与主机应用程序兼容性**

确保NCP应用程序具有必要的核心功能非常重要，以便主机处理器能够依赖NCP来执行其网络功能。例如，如果主机应用程序需要能够发送ZigBeeRF4CE消息，NCP必须包含对从主机处理器处理RF4CEezsp命令的支持。

兼容性是不同的，这取决于您是要构建自定义NCP映像还是使用硅实验室预先构建的固件映像之一。如果您正在使用网络协处理器应用程序框架构建自定义NCP映像，则需要包含宿主应用程序希望执行的功能的库插件，如果主机应用程序从NCP接收了大量ezsp_ERROR_VALID_Frame_id错误值，则需要重新构建映像以包含与这些com-MandS相关的库。

如果您使用的是预先构建的固件映像，那么这个过程就更简单了。当前的预构建产品包括所有Encom传递的NCP映像和仅使用RF4CE的NCP映像。包含所有内容的NCP映像可以正确处理从使用afv 2或RF4CE框架构建的主机发送的任何ezsp帧。因此，无所不包的NCP映像是支持运行在主机应用程序上的通用ZigBee功能的安全选择。仅使用RF4CE的NCP映像只适用于仅用于RF4CE的主机应用程序，该应用程序是通过RF4CE应用程序框架构建的。

下表旨在帮助主机应用程序与合适的NCP应用程序配对。
主机与NCP应用程序兼容性：


| NCP Application (imagename) |Single zigbee PRO Net-work (AFV2)| Dual zigbee PRO + zig-bee PRO Network(AFV2) | Dual zigbee PRO +RF4CE Network (AFV2)|Single RF4CE network(RF4CE ApplicationFramework) |
|:-------------|:-------------:|:-----------:|:-----------:|:-----------:| 
| Custom NCP applica-tion (Network Copro-cessor ApplicationFramework) | YES<br>主机应用程序中的功能必须与NCP配置中的相应插件交互. | YES<br>主机应用程序中的功能必须与NCP配置中的相应插件交互.对于多网络主机配置，多网络库必须包含在NCP配置中. | YES<br>主机应用程序中的功能必须与NCP配置中的相应插件交互.对于多网络主机配置，多网络库必须包含在NCP配置中. | YES<br> 主机应用程序中的功能必须与NCP配置中的相应插件交互.|
|All-encompassing NCPapplications (ncp-spi,ncp-uart, ncp-usb)|YES |YES |YES |YES <br> 虽然主机应用程序可能只运行RF4CE功能，但NCP应用程序仍然可以支持它，而NCP应用程序不支持完整的ZigBeePro支持。|
|RF4CE-only NCP (ncp-rf4ce-spi, ncp-rf4ce-uart, ncp-rf4ce-usb)|NO<br>仅使用rf4ce的ncp映像不包含处理主机zigBee pro ezsp命令所需的功能。|NO<br>仅使用rf4ce的ncp映像不包含处理主机zigBee pro ezsp命令所需的功能。|NO<br>仅使用rf4ce的ncp映像不包含处理主机zigBee pro ezsp命令所需的功能。|YES|

### **3.7 安全**

在设计ZigBeePro应用程序时，有许多安全考虑因素，例如链接密钥的使用、如何派生密钥、身份验证策略等等。有关更多信息，请参见文档ug 103.5，应用程序开发基本原则：安全性。
